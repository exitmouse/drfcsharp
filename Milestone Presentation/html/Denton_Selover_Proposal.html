
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
This HTML is based on that of Nick Foti from last year, which was in turn based on that of Cory Cornelius from the year before.
-->
<html>
<head>
<title>Discriminative Random Fields for Aerial Structure Detection</title>
<style type="text/css">
  body {
    margin: 0px;
    padding: 0px;
    font-family: Verdana;
    font-size: 10pt;
    color: #333;
  }
  
  h4 {
    font-weight: normal;
    font-style: italic;
  }

  p {
    text-align: justify;
  }
  
  #outer {
    margin-left: auto;
    margin-right: auto;
    margin-top: 0px;
    margin-bottom: 0px;
    width: 620px;
    border-left: 3px solid #93CA00;
    border-right: 3px solid #93CA00;
  }

  #content {
    margin-left: auto;
    margin-right: auto;
    width: 600px;
    height: auto;
    padding: 10px;
  }

  #authors {
    font-weight: normal;
    font-style: italic;
    font-size: 11pt;
  }
  
  #extra {
    text-indent: 4em;
  }
</style>

</head>
<body>

<div id="outer">

<div id="content">
<h2>Discriminative Random Fields for Aerial Structure Detection</h2>
<h4 id="authors">Daniel Denton and Jesse Selover</h4>

<p>
The description and motivation of our project remain unchanged since 
the original proposal.  Therefore, we will begin at the point where the 
proposal writeup ended, with the tasks we set for ourselves to complete 
by the milestone date.
</p>

<h3>Recap: Milestone Goal</h3>

<p>
When we began this project, we set out to complete the following tasks 
by the milestone date:
  <ul>
    <li> Writing a short program to facilitate hand-labeling our
    data </li>
    <li> Hand-labeling the data </li>
    <li> Extracting features for each image (pre-processing) </li>
    <li> Coding the DRF model </li>
    <li> Training the DRF model </li>
    <li> Producing preliminary results </li>
  </ul>
</p>

<p>
Now that the milestone date has arrived, we have completed almost all
of these tasks.  In short, we have written our data labeling program, 
and used it to label some (but not all) of our data.  We have successfully 
extracted from our images the feature set that our DRF model uses to 
make its classifications.  We have coded the complete algorithm, with 
both training and inference.  We have trained the algorithm on the 
subset of data which we have labeled so far, although we this using 
a default selection of hyper-parameters which we eventually intend to 
discover using cross validation.  Finally, we have used the trained 
model to classify sites on a few test images, and discovered that 
there is currently a bug in how we are applying the inference when 
we include the interaction potential term.
</p>
<p>
As long as we can find and fix our bug with the use of the interaction 
potential in a reasonable amount of time, we should be on track to tune 
the algorithm, and test its behavior on several datasets, including 
some used by previous researchers [1], [6].
</p>


<h3>Data Labeling</h3>
<p>
We began by deciding to use images of 256x256 pixels split into 256 
16x16 pixel sites (the same site size used by Kumar and Hebert [6]).  
Since the images we acquired from the Montgomery County GIS website 
[8] were larger than this, we used a script to randomly crop each 
image to the desired size.  We also had the same script randomly 
rotate each of our images, because we are interested in performing 
structure detection which is not dependent on compass orientation.
</p>
<p>
Since we need to label 16x16=256 sites for each image, and we intend 
to label 300 of our own images along with some images from the datasets 
of previous researchers, it was imperative that we create a tool 
which simplifies and speeds up the process of creating and storing 
site labelings.  We decided to use python for our data labeling program, 
because the pygame library provides such great tools for easily creating 
a simple point and click application.
</p>

<p>
<center>
<img src="images/Data_Labeler_Screenshot_Cropped.png" width="500" />
<br/>
<caption><span style="font-weight:bold;">Figure 1.</span>  
A screenshot of the data labeler program in mid-labeling.</caption>
</center>
</p>

<p>
One idea that we have been playing around with is to try training the 
model with labelings of only buildings, and also with labelings which 
label every man-made structure (including roads, and driveways, etc.) 
to compare the results.  Thus, we wrote the data labeler to allow us 
to use 3 labels, which form a totally ordered set:
  <ul>
    <li> any_site</li>
    <li> any_structure </li>
    <li> building </li>
  </ul>
</p>

<p>
  By performing our labelings with these three labels, and choosing
  the most specific applicable label for each site, we can easily
  choose the threshold for either of the two binary classifications we
  are interested in training on.
</p>

<p>
  The data labeler continuously backs up the current labeling of each
  image as a comma separated text file which we then read in our C#
  implementation.  This allows the data labeler to load the latest
  labeling of any image.  By outputting our inferred classifications
  of test images to this format, we gain the added benefit of using
  the same data labeler to display our classification results.
</p>

<p>
  We now have the data labeler giving us all of the functionality that
  we foresee wanting from it.  We have used it to label 80 of our
  training images that we could use to begin testing our algorithm.
  At this point, it simply remains to finish the labeling of the
  remaining images in our dataset.
</p>

<p>
  The Kumar-Hebert dataset [6] has kindly been made available to us,
  and it comes pre-labeled.  We hope to also get access to the dataset
  used by Bellman and Shortis [1].  Their images also are 256x256, but
  are only labeled with a single boolean variable for the presence of
  absence of a building.  Thus, in order run our algorithm on their
  data, we will need to perform individual site labelings, which we
  can perform with our same data labeling program.
</p>

<h3>Image Features</h3>
<p>
  We have implemented the single-site image features from [6] because
  they are most useful for comparison with other methods; we should be
  able to implement the multi-scale features with little additional
  trouble later.
</p>
<p>
  The image features are all derived from an initial pixel-by-pixel
  gradient computation. To calculate the gradient vector at a pixel,
  we first convert the image to grayscale using NTSC-recommended
  values (Intensity = 0.299*R + 0.587*G + 0.114*B). Then to get the
  directional x-derivative, we convolve the resultant matrix of
  intensities with the derivative of a gaussian horizontally and the
  original gaussian vertically; the process is analogous for the
  directional y-derivative. We wrote code in C# to do this; we found
  no library to do it for us.
</p>
<p>
  The variance of the gaussian is a hyper-parameter; we will have to
  optimize it. For now, we contacted Kumar and Hebert and they say
  they used 0.5 which seems like a decent, upstanding number that we
  don't really object to much. The algorithm is coded referencing the
  number only as a constant, so we can change it easily.
</p>
<p>
  We bin the gradients of the pixels in each site into a histogram
  array indexed by orientations; we weight their contributions by
  their L2 norms. We chose to smooth the histogram with a simple
  triangular kernel, rather than the gaussian kernel of [6]; this will
  be very simple to change later.
</p>
<p>
  The number of bins in the histogram is also a hyper-parameter; we
  can change it in the code by editing one variable. We chose 8 bins
  as a preliminary step, based on our research from [10]
</p>
<p>
  Then the features we compute are heaved central-shift moments
  v<sub>p</sub> of the 0th through 2nd order. v<sub>0</sub> is defined
  as the arithmetic mean of the magnitudes. Let the bins be
  E<sub>i</sub> and let H(x) be the indicator function for the
  positive real numbers; then v<sub>p</sub> for p > 0 is defined as
</p>

<p>
<center>
<img src="images/eqn1.png"/>
</center>
</p>

<p>
  In addition, we compute the absolute value of the sine of the angle
  difference between the two highest peaks of the histogram, to
  measure the presence of near-right-angle junctions.
</p>
<p>
  In the original [6] paper, Kumar and Hebert also used the angle of
  the highest peak to perhaps allow their algorithm to catch on to the
  predominance of vertical lines in man-made structures in their
  data-set. However, our photos are not taken from upright cameras,
  houses did not tend to be aligned with the cameras, and in fact we
  randomly rotated the images in preprocessing to enforce this
  invariance, so we removed this feature. It should not be useful for
  our application; it would function as random noise.
</p>
<p>
  As we said earlier, we only coded the single-site feature vector,
  but the remaining features from [6] were all simple functions of the
  pixel-wise gradient histograms, so we will be able to implement them
  if necessary.
</p>

<h3>Modified Model</h3>
<p>
  We decided to use the modified DRF model presented in [6], as the
  learning objective is convex and it promised to be slightly easier
  to train. Kumar and Hebert suggest gradient ascent to maximize the
  log-likelihood, but we had to re-derive the gradients with respect
  to the vector parameters of the model.
</p>
<p>
  In exchange, however, the algorithm for inference became slightly
  more technical. We were planning on using iterated conditional
  modes; iterating over the image assigning to each site the label of
  maximum likelihood given its neighbors. With the modified DRF model,
  though, you can compute exact MAP estimates of the labeling with an
  algorithm presented in [3] as mentioned in [6].
</p>

<h3>Training</h3>
<p>
  We had a lot of fun re-deriving the gradient of the log likelihood
  to ascend it: We want to find
</p>

<p>
<center>
<img src="images/eqn2.png"/>
</center>
</p>
<p>
  So we calculate:
</p>

<p>
<center>
<img src="images/eqn3.png"/>
</center>
</p>

<p>
  where
</p>

<p>
<center>
<img src="images/eqn4.png"/>
</center>
</p>

<p>
  Similarly, for v,
</p>

<p>
<center>
<img src="images/eqn5.png"/>
</center>
</p>

<p>
  where
</p>

<p>
<center>
<img src="images/eqn6.png"/>
</center>
</p>

<h3>Issues with the Training</h3>


<h3>Data</h3>

<p>
<center>
<img src="images/eqn1.pdf" />
<br/>
<caption><span style="font-weight:bold;">Figure 1.</span>  
A screenshot of the data labeler program in mid-labeling.</caption>
</center>
</p>

<p>
  We were fortunate to find a public online archive of high-quality
  orthophotos of the entirety of Montgomery County, Maryland at the
  Montgomery County GIS website [5].  We intend to use selections from
  this archive for our training and test data.  Since we will be
  performing supervised learning, each of these images will require
  labeling.  We plan to write a program to assist us in labeling our
  images.  Our program will superimpose a grid showing the site
  divisions, and and it will serve to capture site-labelings as user
  user mouse clicks.  In this manner we can reasonably expect to label
  and use a couple hundred such images.
</p>

<h3>Milestone Goal</h3>
<p>
  By the milestone we aim to complete the following tasks:
  <ul>
    <li> Writing a short program to facilitate hand-labeling our
    data </li>
    <li> Hand-labeling the data </li>
    <li> Extracting features for each image (pre-processing) </li>
    <li> Coding the DRF model </li>
    <li> Training the DRF model </li>
    <li> Producing preliminary results </li>
  </ul>
</p>

<h3>References</h3>
<ol>
  <li> C. J. Bellman and M. R. Shortis. A machine learning approach to building recognition in aerial photographs. In International Archives of the Photogrammetry, Remote Sensing and Spatial Information Sciences, pages 50-54, 2002.</li>

  <li> Sanjiv Kumar and Martial Hebert. Discriminative random fields: a discriminative framework for contextual interaction in classification. In Computer Vision, 2003. Proceedings. Ninth IEEE International Conference on, pages 1150-1157 vol.2, oct. 2003.</li>

  <li> Sanjiv Kumar and Martial Hebert. Discriminative random fields. International Journal of Computer Vision, 68(2):179-202, 2006.</li>

  <li> John D. Lafferty, Andrew McCallum, and Fernando C. N. Pereira. Conditional random fields: Probabilistic models for segmenting and labeling sequence data. In Carla E. Brodley and Andrea Pohoreckyj Danyluk, editors, ICML, pages 282-289. Morgan Kaufmann, 2001.</li>

  <li> Maryland GIS Montgomery County, April 2012.</li>

  <li> Fanhuai Shi, Yongjian Xi, Xiaoling Li, and Ye Duan. Rooftop detection and 3d building modeling from aerial images. In George Bebis, Richard Boyle, Bahram Parvin, Darko Koracin, Yoshinori Kuno, Junxian Wang, Renato Pajarola, Peter Lindstrom, Andr Hinkenjann, Miguel Encarnao, Cludio Silva, and Daniel Coming, editors, Advances in Visual Computing, volume 5876 of Lecture Notes in Computer Science, pages 817-826. Springer Berlin / Heidelberg, 2009.</li>

  <li> various. Wikipedia: Orthophoto, April 2012</li>
</ol>

</div>

</div>

</body>
</html>
